# -*- coding: utf-8 -*-
"""KNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vBKpfcjnPlnW1wAZIL-yerzbEumSfo51
"""

import numpy as np

from scipy import stats

class knn(object):

  def fit(self,x_train,y_train,k):                 #saving the training data set
    self.k = k                                     #k is the no. of nearest neighbours
    self.X = np.array(x_train)
    self.y = np.array(y_train)

  def predict(self,x_test):                        #predicting the class of test data 
    x = np.array(x_test)
    m = x.shape[0]
    y_pred = np.zeros((m,1))  
    for a in range(m):                             #finding distances between a given point and the training data  
      dist = np.sum((self.X-x[a,:])**2,axis=1)
      dist = np.vstack((dist,self.y))
      b = np.argsort(dist[0,:])                    #arranging the distances in ascending order
      l = b[0:self.k]                              #storing the indices of the k nearest points
      y_pred[a] = stats.mode(dist[1,l]).mode       #assigning the class which is most frequent to the test point 
    return y_pred

  def split_train_test(self,X,y,split):            #splitting the data set into training and test sets based on the split fraction
        m = size()
        n = split*np.size(y,axis=0)
        x_train = X[0:n,:]
        x_test = X[n:,:]
        y_train = y[0:n]
        y_test = y[n:]
        return x_train,x_test,y_train,y_test  

  def accuracy(self,y_true,y_pred):                #classifies a prediction as correct only if it is equal to the original class
    m = len(y_true)
    acc=0
    for a in range(m):
      if y_pred[a]==y_true[a]: acc+=1
    return (acc*100)/m